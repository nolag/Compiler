// Autogenerated code. Do not modify this file manually.
package cs444.parser.rules;
import java.util.HashMap;
import java.util.Map;

import cs444.lexer.Token;
import cs444.parser.IParserRule;
import cs444.parser.symbols.StateTerminal;
import cs444.parser.symbols.factories.ISymbolFactory;
import cs444.parser.symbols.factories.NonTerminalFactory;
import cs444.parser.symbols.factories.TerminalFactory;

public class Tmp implements IParserRule{
    private final NonTerminalFactory startFact;
    public Tmp() {
        new TerminalFactory(Token.Type.FOR);
        new TerminalFactory(Token.Type.CHAR);
        new TerminalFactory(Token.Type.DECIMAL_INTEGER_LITERAL);
        new TerminalFactory(Token.Type.PACKAGE);
        new TerminalFactory(Token.Type.GE);
        new TerminalFactory(Token.Type.LONG);
        new TerminalFactory(Token.Type.FLOAT);
        new TerminalFactory(Token.Type.DOT);
        new TerminalFactory(Token.Type.BREAK);
        new TerminalFactory(Token.Type.RPAREN);
        new TerminalFactory(Token.Type.PCT);
        new TerminalFactory(Token.Type.BYTE);
        new TerminalFactory(Token.Type.FALSE);
        new TerminalFactory(Token.Type.IMPORT);
        new TerminalFactory(Token.Type.BOOLEAN);
        Map<Integer, Map<Token.Type, StateTerminal>>DCLSRules = new HashMap<Integer, Map<Token.Type, StateTerminal>>();
        Map<Integer, String> DCLSAccepting = new HashMap<Integer, String>();
        new NonTerminalFactory(DCLSRules, DCLSAccepting, "DCLS");
        new TerminalFactory(Token.Type.EXCLAMATION);
        new TerminalFactory(Token.Type.ELSE);
        new TerminalFactory(Token.Type.VOLATILE);
        new TerminalFactory(Token.Type.FINAL);
        new TerminalFactory(Token.Type.PLUS);
        new TerminalFactory(Token.Type.COMMA);
        new TerminalFactory(Token.Type.MINUS);
        new TerminalFactory(Token.Type.STATIC);
        new TerminalFactory(Token.Type.LPAREN);
        new TerminalFactory(Token.Type.SYNCHRONIZED);
        new TerminalFactory(Token.Type.EXTENDS);
        new TerminalFactory(Token.Type.INT);
        new TerminalFactory(Token.Type.THROWS);
        new TerminalFactory(Token.Type.TRANSIENT);
        new TerminalFactory(Token.Type.WHITESPACE);
        new TerminalFactory(Token.Type.CLASS);
        new TerminalFactory(Token.Type.ENUM);
        new TerminalFactory(Token.Type.DOUBLE);
        new TerminalFactory(Token.Type.DEFAULT);
        new TerminalFactory(Token.Type.LE);
        new TerminalFactory(Token.Type.NATIVE);
        new TerminalFactory(Token.Type.INSTANCEOF);
        new TerminalFactory(Token.Type.DAMPERSAND);
        new TerminalFactory(Token.Type.GT);
        new TerminalFactory(Token.Type.CASE);
        new TerminalFactory(Token.Type.COMMENT);
        Map<Integer, Map<Token.Type, StateTerminal>>DCLS_OR_BECOMESRules = new HashMap<Integer, Map<Token.Type, StateTerminal>>();
        Map<Integer, String> DCLS_OR_BECOMESAccepting = new HashMap<Integer, String>();
        NonTerminalFactory DCLS_OR_BECOMES = new NonTerminalFactory(DCLS_OR_BECOMESRules, DCLS_OR_BECOMESAccepting, "DCLS_OR_BECOMES");
        new TerminalFactory(Token.Type.THIS);
        new TerminalFactory(Token.Type.TRY);
        new TerminalFactory(Token.Type.LBRACE);
        Map<Integer, Map<Token.Type, StateTerminal>>BECOMES2Rules = new HashMap<Integer, Map<Token.Type, StateTerminal>>();
        Map<Integer, String> BECOMES2Accepting = new HashMap<Integer, String>();
        new NonTerminalFactory(BECOMES2Rules, BECOMES2Accepting, "BECOMES2");
        Map<Integer, Map<Token.Type, StateTerminal>>BECOMES3Rules = new HashMap<Integer, Map<Token.Type, StateTerminal>>();
        Map<Integer, String> BECOMES3Accepting = new HashMap<Integer, String>();
        new NonTerminalFactory(BECOMES3Rules, BECOMES3Accepting, "BECOMES3");
        Map<Integer, Map<Token.Type, StateTerminal>>BECOMES1Rules = new HashMap<Integer, Map<Token.Type, StateTerminal>>();
        Map<Integer, String> BECOMES1Accepting = new HashMap<Integer, String>();
        new NonTerminalFactory(BECOMES1Rules, BECOMES1Accepting, "BECOMES1");
        new TerminalFactory(Token.Type.CONST);
        new TerminalFactory(Token.Type.BECOMES);
        new TerminalFactory(Token.Type.CATCH);
        new TerminalFactory(Token.Type.FINALLY);
        new TerminalFactory(Token.Type.GOTO);
        new TerminalFactory(Token.Type.SWITCH);
        new TerminalFactory(Token.Type.RBRACE);
        new TerminalFactory(Token.Type.LT);
        Map<Integer, Map<Token.Type, StateTerminal>>BECOMES4Rules = new HashMap<Integer, Map<Token.Type, StateTerminal>>();
        Map<Integer, String> BECOMES4Accepting = new HashMap<Integer, String>();
        new NonTerminalFactory(BECOMES4Rules, BECOMES4Accepting, "BECOMES4");
        new TerminalFactory(Token.Type.PIPE);
        new TerminalFactory(Token.Type.WHILE);
        new TerminalFactory(Token.Type.PRIVATE);
        Map<Integer, Map<Token.Type, StateTerminal>>BECOMESRules = new HashMap<Integer, Map<Token.Type, StateTerminal>>();
        Map<Integer, String> BECOMESAccepting = new HashMap<Integer, String>();
        new NonTerminalFactory(BECOMESRules, BECOMESAccepting, "BECOMES");
        new TerminalFactory(Token.Type.SHORT);
        new TerminalFactory(Token.Type.SUPER);
        new TerminalFactory(Token.Type.ID);
        new TerminalFactory(Token.Type.END_LINE_COMMENT);
        new TerminalFactory(Token.Type.THROW);
        new TerminalFactory(Token.Type.PROTECTED);
        new TerminalFactory(Token.Type.STR_LITERAL);
        new TerminalFactory(Token.Type.IF);
        new TerminalFactory(Token.Type.DO);
        new TerminalFactory(Token.Type.NULL);
        new TerminalFactory(Token.Type.STRICTFP);
        new TerminalFactory(Token.Type.ABSTRACT);
        new TerminalFactory(Token.Type.SLASH);
        new TerminalFactory(Token.Type.LBRACKET);
        new TerminalFactory(Token.Type.STAR);
        new TerminalFactory(Token.Type.RETURN);
        new TerminalFactory(Token.Type.VOID);
        new TerminalFactory(Token.Type.TRUE);
        new TerminalFactory(Token.Type.SEMI);
        new TerminalFactory(Token.Type.INTERFACE);
        new TerminalFactory(Token.Type.AMPERSAND);
        new TerminalFactory(Token.Type.CHAR_LITERAL);
        new TerminalFactory(Token.Type.RBRACKET);
        Map<Integer, Map<Token.Type, StateTerminal>>DCLS1Rules = new HashMap<Integer, Map<Token.Type, StateTerminal>>();
        Map<Integer, String> DCLS1Accepting = new HashMap<Integer, String>();
        new NonTerminalFactory(DCLS1Rules, DCLS1Accepting, "DCLS1");
        new TerminalFactory(Token.Type.NEW);
        new TerminalFactory(Token.Type.DPIPE);
        Map<Integer, Map<Token.Type, StateTerminal>>DCLS2Rules = new HashMap<Integer, Map<Token.Type, StateTerminal>>();
        Map<Integer, String> DCLS2Accepting = new HashMap<Integer, String>();
        new NonTerminalFactory(DCLS2Rules, DCLS2Accepting, "DCLS2");
        new TerminalFactory(Token.Type.NE);
        new TerminalFactory(Token.Type.CONTINUE);
        new TerminalFactory(Token.Type.IMPLEMENTS);
        new TerminalFactory(Token.Type.ASSERT);
        new TerminalFactory(Token.Type.PUBLIC);
        new TerminalFactory(Token.Type.EQ);

        startFact = DCLS_OR_BECOMES;
    }

    public ISymbolFactory getStartSymbol() {
        return startFact;
    }
}
