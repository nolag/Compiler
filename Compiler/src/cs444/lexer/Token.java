//******************************************************
// Autogenerated code. Do not modify this file manually.
//******************************************************
package cs444.lexer;

import java.util.HashMap;
import java.util.Map;
public final class Token {
    public enum Type {
        IF,
        SWITCH,
        TRY,
        AMPERSAND,
        DAMPERSAND,
        IMPLEMENTS,
        IMPORT,
        CHAR_LITERAL,
        COMMA,
        LBRACE,
        END_LINE_COMMENT,
        EXTENDS,
        WHITESPACE,
        DOT,
        FOR,
        TRANSIENT,
        STATIC,
        DPIPE,
        PRIVATE,
        ENUM,
        MINUS,
        SUPER,
        PUBLIC,
        GE,
        PCT,
        INT,
        FINAL,
        CHAR,
        LBRACKET,
        DEFAULT,
        PLUS,
        CONST,
        ABSTRACT,
        VOLATILE,
        THROW,
        BREAK,
        BOOLEAN,
        DOUBLE,
        COMMENT,
        RPAREN,
        RBRACE,
        ID,
        PROTECTED,
        TRUE,
        BYTE,
        STRICTFP,
        NEW,
        CATCH,
        LONG,
        CONTINUE,
        SHORT,
        CASE,
        NATIVE,
        BECOMES,
        THIS,
        STR_LITERAL,
        THROWS,
        NE,
        EQ,
        GOTO,
        FALSE,
        NULL,
        ASSERT,
        FLOAT,
        WHILE,
        ELSE,
        DO,
        PACKAGE,
        EXCLAMATION,
        DECIMAL_INTEGER_LITERAL,
        INSTANCEOF,
        GT,
        SEMI,
        RETURN,
        LE,
        PIPE,
        SYNCHRONIZED,
        FINALLY,
        RBRACKET,
        LPAREN,
        VOID,
        CLASS,
        SLASH,
        LT,
        INTERFACE,
        STAR,
        EOF
    }
    public static enum Parse {VALID, SYNTAX_ONLY, IGNORE}
    public static final Map<Type, Parse> typeToParse = new HashMap<Type, Parse>(){{put(Type.IF, Parse.VALID); put(Type.SWITCH, Parse.VALID); put(Type.TRY, Parse.VALID); put(Type.AMPERSAND, Parse.VALID); put(Type.DAMPERSAND, Parse.VALID); put(Type.IMPLEMENTS, Parse.VALID); put(Type.IMPORT, Parse.VALID); put(Type.CHAR_LITERAL, Parse.VALID); put(Type.COMMA, Parse.SYNTAX_ONLY); put(Type.LBRACE, Parse.SYNTAX_ONLY); put(Type.END_LINE_COMMENT, Parse.IGNORE); put(Type.EXTENDS, Parse.SYNTAX_ONLY); put(Type.WHITESPACE, Parse.IGNORE); put(Type.DOT, Parse.SYNTAX_ONLY); put(Type.FOR, Parse.VALID); put(Type.TRANSIENT, Parse.VALID); put(Type.STATIC, Parse.VALID); put(Type.DPIPE, Parse.VALID); put(Type.PRIVATE, Parse.VALID); put(Type.ENUM, Parse.VALID); put(Type.MINUS, Parse.VALID); put(Type.SUPER, Parse.VALID); put(Type.PUBLIC, Parse.VALID); put(Type.GE, Parse.VALID); put(Type.PCT, Parse.VALID); put(Type.INT, Parse.VALID); put(Type.FINAL, Parse.VALID); put(Type.CHAR, Parse.VALID); put(Type.LBRACKET, Parse.SYNTAX_ONLY); put(Type.DEFAULT, Parse.VALID); put(Type.PLUS, Parse.VALID); put(Type.CONST, Parse.VALID); put(Type.ABSTRACT, Parse.VALID); put(Type.VOLATILE, Parse.VALID); put(Type.THROW, Parse.VALID); put(Type.BREAK, Parse.VALID); put(Type.BOOLEAN, Parse.VALID); put(Type.DOUBLE, Parse.VALID); put(Type.COMMENT, Parse.IGNORE); put(Type.RPAREN, Parse.SYNTAX_ONLY); put(Type.RBRACE, Parse.SYNTAX_ONLY); put(Type.ID, Parse.VALID); put(Type.PROTECTED, Parse.VALID); put(Type.TRUE, Parse.VALID); put(Type.BYTE, Parse.VALID); put(Type.STRICTFP, Parse.VALID); put(Type.NEW, Parse.VALID); put(Type.CATCH, Parse.VALID); put(Type.LONG, Parse.VALID); put(Type.CONTINUE, Parse.VALID); put(Type.SHORT, Parse.VALID); put(Type.CASE, Parse.VALID); put(Type.NATIVE, Parse.VALID); put(Type.BECOMES, Parse.VALID); put(Type.THIS, Parse.VALID); put(Type.STR_LITERAL, Parse.VALID); put(Type.THROWS, Parse.VALID); put(Type.NE, Parse.VALID); put(Type.EQ, Parse.VALID); put(Type.GOTO, Parse.VALID); put(Type.FALSE, Parse.VALID); put(Type.NULL, Parse.VALID); put(Type.ASSERT, Parse.VALID); put(Type.FLOAT, Parse.VALID); put(Type.WHILE, Parse.VALID); put(Type.ELSE, Parse.VALID); put(Type.DO, Parse.VALID); put(Type.PACKAGE, Parse.VALID); put(Type.EXCLAMATION, Parse.VALID); put(Type.DECIMAL_INTEGER_LITERAL, Parse.VALID); put(Type.INSTANCEOF, Parse.VALID); put(Type.GT, Parse.VALID); put(Type.SEMI, Parse.SYNTAX_ONLY); put(Type.RETURN, Parse.VALID); put(Type.LE, Parse.VALID); put(Type.PIPE, Parse.VALID); put(Type.SYNCHRONIZED, Parse.VALID); put(Type.FINALLY, Parse.VALID); put(Type.RBRACKET, Parse.SYNTAX_ONLY); put(Type.LPAREN, Parse.SYNTAX_ONLY); put(Type.VOID, Parse.VALID); put(Type.CLASS, Parse.SYNTAX_ONLY); put(Type.SLASH, Parse.VALID); put(Type.LT, Parse.VALID); put(Type.INTERFACE, Parse.SYNTAX_ONLY); put(Type.STAR, Parse.VALID); }};
    public final Type type;
    public final String lexeme;
    public Token(Type type, String lexeme) {
        this.type = type;
        this.lexeme = lexeme;
    }
    @Override
    public String toString() {
        return "<" + type.toString() + ", " + lexeme.trim() + ">";
    }
}
