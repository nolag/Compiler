// you can use comments

QualifiedIdentifier:

id { dot id }

Literal:

IntegerLiteral

char_literal

str_literal

BooleanLiteral

null

IntegerLiteral:

decimal_integer_literal

BooleanLiteral:

(true | false)

Expression:

Expression1 [AssignmentOperator Expression1]

AssignmentOperator:

=

Type:

id { dot id } BracketsOpt

BasicType

StatementExpression:

Expression

ConstantExpression:

Expression

Expression1:

Expression2

Expression2:

Expression3 [Expression2Rest]

Expression2Rest:

// {Infixop Expression3}        // TODO: fix this rule

// Expression3 instanceof Type   // I think Expression3 should not be here
instanceof Type

Infixop:

dpipe

dampersand

pipe

// ^ TODO: Is this not a feature?

ampersand

eq

ne

lt

gt

le

ge

plus

minus

star

slash

pct

Expression3:

PrefixOp Expression3

Type Expression3     // TODO: check if we actually need the whole rule
// ( Expression | Type ) Expression3     // this one is odd. It's not italic in "The specs", but seems to be a BNF expr

Primary {Selector}

Primary:

ParExpression

Literal

// new Creator        // TODO: fix this rule

// id { . id } [ IdentifierSuffix]         // TODO: fix this rule

IdentifierSuffix:

lbracket ( Expression ) rbracket

Arguments

PrefixOp:

!

+

-

Selector:

. id [Arguments]

lbracket Expression rbracket

BasicType:

byte

short

char

int

long

float

double

boolean

ArgumentsOpt:

[ Arguments ]

Arguments:

lparen [Expression { , Expression }] rparen

BracketsOpt:

{ lbracket rbracket }

Creator:

QualifiedIdentifier ( ArrayCreatorRest | ClassCreatorRest )

ArrayCreatorRest:

lbracket Expression rbracket

ClassCreatorRest:

Arguments [ClassBody]

VariableInitializer:

Expression

ParExpression:

lparen Expression rparen

Block:

lbrace BlockStatements rbrace

BlockStatements:

{ BlockStatement }

BlockStatement:

LocalVariableDeclarationStatement

Statement

LocalVariableDeclarationStatement:

[final] Type VariableDeclarators ;

Statement:

Block

if ParExpression Statement [else Statement]

for lparen ForInit ; [Expression] ; ForUpdate rparen Statement

while ParExpression Statement

do Statement while ParExpression ;

return [Expression] ;

;

StatementExpression

MoreStatementExpressions:

{ , StatementExpression }

ForInit:

StatementExpression MoreStatementExpressions

[final] Type VariableDeclarators

ForUpdate:

StatementExpression MoreStatementExpressions

Modifier:

public

protected

private

static

abstract

final

native

synchronized

transient

volatile

strictfp

VariableDeclarators:

VariableDeclarator { , VariableDeclarator }

VariableDeclaratorsRest:

VariableDeclaratorRest { , VariableDeclarator }

ConstantDeclaratorsRest:

ConstantDeclaratorRest { , ConstantDeclarator }

VariableDeclarator:

id VariableDeclaratorRest

ConstantDeclarator:

id ConstantDeclaratorRest

VariableDeclaratorRest:

BracketsOpt [= VariableInitializer]

ConstantDeclaratorRest:

BracketsOpt = VariableInitializer

VariableDeclaratorId:

id BracketsOpt

CompilationUnit:

[package QualifiedIdentifier ; ] {ImportDeclaration} {TypeDeclaration}

ImportDeclaration:

import id { . id } [ . * ] ;

TypeDeclaration:

{Modifier} (ClassDeclaration | InterfaceDeclaration)

;

ClassDeclaration:

class id [extends Type] ClassBody

class id [extends Type] implements TypeList ClassBody

InterfaceDeclaration:

interface id [extends TypeList] InterfaceBody

TypeList:

Type { , Type}

ClassBody:

lbrace {ClassBodyDeclaration} rbrace

InterfaceBody:

lbrace {InterfaceBodyDeclaration} rbrace

ClassBodyDeclaration:

{Modifier} MemberDecl

MemberDecl:

;

MethodOrFieldDecl

// void id MethodDeclaratorRest // TODO: fix this rule.

// id ConstructorDeclaratorRest // TODO: fix this rule.

MethodOrFieldDecl:

Type id MethodOrFieldRest

MethodOrFieldRest:

VariableDeclaratorRest

// MethodDeclaratorRest // TODO: fix this rule

InterfaceBodyDeclaration:

;

// {Modifier} InterfaceMemberDecl  // TODO: fix this rule

InterfaceMemberDecl:

InterfaceMethodOrFieldDecl

// void id VoidInterfaceMethodDeclaratorRest

InterfaceMethodOrFieldDecl:

Type id InterfaceMethodOrFieldRest

InterfaceMethodOrFieldRest:

ConstantDeclaratorsRest ;

InterfaceMethodDeclaratorRest

MethodDeclaratorRest:

FormalParameters BracketsOpt (MethodBody | ; )

VoidMethodDeclaratorRest:

FormalParameters ( MethodBody | ; )

InterfaceMethodDeclaratorRest:

FormalParameters BracketsOpt ;

VoidInterfaceMethodDeclaratorRest:

FormalParameters ;

ConstructorDeclaratorRest:

FormalParameters MethodBody

QualifiedIdentifierList:

QualifiedIdentifier { , QualifiedIdentifier}

FormalParameters:

( [FormalParameter { , FormalParameter}] )

FormalParameter:

[final] Type VariableDeclaratorId

MethodBody:

Block
