// you can use comments

QualifiedIdentifier:

id { dot id }

Literal:

IntegerLiteral

char_literal

str_literal

BooleanLiteral

null

IntegerLiteral:

decimal_integer_literal

BooleanLiteral:

(true | false)

Type:

id { dot id } BracketsOpt

BasicType

StatementExpression:

Expression

Expression:

Expression1 [ = Expression]

Expression1:

[Expression1 dpipe] Expression2

Expression2:

[Expression2 dampersand] Expression3

Expression3:

[Expression3 pipe] Expression4

Expression4:

[Expression4 &] Expression5

Expression5:

[Expression5 ( == | != )] Expression6

Expression6:

Expression6 instanceof Type

[Expression6 ( < | > | <= | >= )] Expression7

Expression7:

[Expression7 ( + | - )] Expression8

Expression8:

[Expression8 ( * | / | % )] Expression9

Expression9:

[( - | + | ! )] Primary

// Primary {Selector}   // TODO: fix this

Primary:

ParExpression

// CastExpression // TODO: fix this

Literal

this  // TODO: not sure if we support this.field

new Creator

id { . id } [ IdentifierSuffix ]

IdentifierSuffix:

lbracket Expression rbracket

Arguments

CastExpression:

lparen Type rparen Expression

// Selector:

// . id [Arguments]

// ^ TODO: Is this not a feature?

// TODO: investigate this rule. It is from original version of Syntax
// ( Expression | Type ) Expression3     // this one is odd. It's not italic in "The specs", but seems to be a BNF expr

BasicType:

byte

short

char

int

long

float

double

boolean

Arguments:

lparen [Expression { , Expression }] rparen

BracketsOpt:

[ lbracket rbracket ]   // O or 1 because Joos doesnt support multi array

Creator:

QualifiedIdentifier ( ArrayCreatorRest | ClassCreatorRest )

ArrayCreatorRest:

lbracket Expression rbracket

ClassCreatorRest:

Arguments [ClassBody]

VariableInitializer:

Expression

ParExpression:

lparen Expression rparen

Block:

lbrace BlockStatements rbrace

BlockStatements:

{ BlockStatement }

BlockStatement:

LocalVariableDeclarationStatement

Statement

LocalVariableDeclarationStatement:

Type VariableDeclarators ;

Statement:

OpenStatement

ClosedStatement

OpenStatement:

if ParExpression Statement

if ParExpression ClosedStatement else OpenStatement

ForLoopHeader OpenStatement

WhileLoopHeader OpenStatement

ClosedStatement:

Block

if ParExpression ClosedStatement else ClosedStatement

ForLoopHeader ClosedStatement

WhileLoopHeader ClosedStatement

do Statement while ParExpression ;

return [Expression] ;

;

StatementExpression ;

ForLoopHeader:

for lparen [ForInit] ; [Expression] ; [ForUpdate] rparen

WhileLoopHeader:

while ParExpression

MoreStatementExpressions:

{ , StatementExpression }

ForInit:

StatementExpression MoreStatementExpressions

Type VariableDeclarators

ForUpdate:

StatementExpression MoreStatementExpressions

Modifier:

public

protected

private

static

abstract

final

native

synchronized

transient

volatile

strictfp

VariableDeclarators:

VariableDeclarator { , VariableDeclarator }

VariableDeclaratorsRest:

VariableDeclaratorRest { , VariableDeclarator }

ConstantDeclaratorsRest:

ConstantDeclaratorRest { , ConstantDeclarator }

VariableDeclarator:

id VariableDeclaratorRest

ConstantDeclarator:

id ConstantDeclaratorRest

VariableDeclaratorRest:

[= VariableInitializer]

ConstantDeclaratorRest:

BracketsOpt = VariableInitializer

VariableDeclaratorId:

id BracketsOpt

CompilationUnit:

[package QualifiedIdentifier ; ] {ImportDeclaration} {TypeDeclaration}

ImportDeclaration:

import id { . id } [ . * ] ;

TypeDeclaration:

{Modifier} (ClassDeclaration | InterfaceDeclaration)

;

ClassDeclaration:

class id [extends Type] ClassBody

class id [extends Type] implements TypeList ClassBody

InterfaceDeclaration:

interface id [extends TypeList] InterfaceBody

TypeList:

Type { , Type}

ClassBody:

lbrace {ClassBodyDeclaration} rbrace

InterfaceBody:

lbrace {InterfaceBodyDeclaration} rbrace

ClassBodyDeclaration:

{Modifier} MemberDecl

MemberDecl:

;

( MethodDecl | FieldDecl )

MethodDecl:

(BasicType | QualifiedIdentifier) BracketsOpt MethodDeclaratorRest MethodBody

void MethodDeclaratorRest MethodBody

id ConstructorDeclaratorRest

FieldDecl:

BasicType BracketsOpt id VariableDeclaratorRest ;

QualifiedIdentifier BracketsOpt id VariableDeclaratorRest ;

InterfaceBodyDeclaration:

;

{Modifier} InterfaceMemberDecl

InterfaceMemberDecl:

InterfaceMethodOrFieldDecl

void id VoidInterfaceMethodDeclaratorRest

InterfaceMethodOrFieldDecl:

Type id InterfaceMethodOrFieldRest

InterfaceMethodOrFieldRest:

ConstantDeclaratorsRest ;

InterfaceMethodDeclaratorRest

MethodDeclaratorRest:

id FormalParameters

VoidMethodDeclaratorRest:

FormalParameters ( MethodBody | ; )

InterfaceMethodDeclaratorRest:

FormalParameters BracketsOpt ;

VoidInterfaceMethodDeclaratorRest:

FormalParameters ;

ConstructorDeclaratorRest:

FormalParameters MethodBody

FormalParameters:

lparen [FormalParameter { , FormalParameter}] rparen

FormalParameter:

[final] Type VariableDeclaratorId

MethodBody:

;

Block
