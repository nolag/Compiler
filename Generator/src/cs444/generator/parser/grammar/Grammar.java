package cs444.generator.parser.grammar;

import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import cs444.generator.Generator;
import cs444.generator.lexer.grammar.LexicalGrammar;
import cs444.generator.lexer.grammar.TokenMetadata;
import cs444.generator.parser.Rule;
import cs444.generator.parser.TempRule;
import cs444.generator.parser.TerminalRule;
import cs444.generator.parser.exceptions.UndeclaredRuleException;

public class Grammar extends Generator{
	private final Map<String, Rule> ruleMap = new HashMap<String, Rule>();
	private final Map<String, TempRule> tempMap = new HashMap<String, TempRule>();
	private final String name;
	private final String startRule;

	public Grammar(String name, String startRule, LexicalGrammar tokenGrammar, Writer writer){
	    super(writer);
	    this.name = name;
	    this.startRule = startRule;
		TokenMetadata [] metaDataList = tokenGrammar.getTokenMetadata();
		for(TokenMetadata metaData :  metaDataList){
			String ruleName = metaData.name.toLowerCase();
			Rule rule = TerminalRule.create(ruleName);
			ruleMap.put(ruleName, rule);
		}
	}

	private List<Rule> makeAddRule(String name, TempRule me, String ... ruleNames){
	    Rule [] rules = new Rule[ruleNames.length];
	    for(int i = 0; i < ruleNames.length; i++){
            String ruleName = ruleNames[i];
            if(ruleName == name) rules[i] = me;
            rules[i] = ruleMap.get(ruleName);
            if(rules[i] == null){
                TempRule temp = new TempRule(ruleName);
                ruleMap.put(ruleName, temp);
                tempMap.put(ruleName, temp);
                rules[i] = temp;
            }
        }
	    return Rule.concatinate(name, rules);
	}

	public Rule makeAddRule(String name, String ruleName){
	    TempRule me = tempMap.get(name);
	    if(me == null) me = new TempRule(name);
	    List<Rule> rules = makeAddRule(name, me, ruleName.split(" "));
	    me.set(rules.get(rules.size() - 1));
	    //Need to make sure all refereces to the rule are the same so the temp needs to stay if it was already used
	    for(Rule rule : rules){
	        ruleMap.put(rule.name, rule);

	    }
	    return rules.get(rules.size() - 1);
	}

	public void addRule(List<Rule> rules){
	    for(Rule rule : rules) ruleMap.put(rule.name, rule);
	}

	public Rule getRule(String name){
	    return ruleMap.get(name);
	}

    @Override
    public void generate() throws IOException, UndeclaredRuleException {
        writeLine("// Autogenerated code. Do not modify this file manually.");
        writeLine("package cs444.parser.rules;");
        writeLine("import java.util.HashMap;");
        writeLine("import java.util.HashSet;");
        writeLine("import java.util.Map;");
        writeLine("import java.util.Set;");
        writeLine("");
        writeLine("import cs444.lexer.Token;");
        writeLine("import cs444.lexer.Token.Type;");
        writeLine("import cs444.parser.IParserRule;");
        writeLine("import cs444.parser.symbols.factories.ISymbolFactory;");
        writeLine("import cs444.parser.symbols.factories.NonTerminalFactory;");
        writeLine("import cs444.parser.symbols.factories.TerminalFactory;");
        writeLine("import cs444.parser.symbols.StateTerminal;");
        writeLine("");
        writeLine("public class " + name + " implements IParserRule{");
        indent();
        writeLine("private final NonTerminalFactory startFact;");
        writeLine("public " + name +"() {");
        indent();

        for(Rule rule : ruleMap.values()){
            List<String> rules = rule.generateDcl();
            for(String genRule : rules) writeLine(genRule);
        }

        for(Rule rule : ruleMap.values()){
            List<String> rules = rule.generateBody();
            for(String genRule : rules) writeLine(genRule);
        }

        writeLine("");
        writeLine("startFact = " + startRule + ";");
        dedent();
        writeLine("}");
        writeLine("");
        writeLine("public ISymbolFactory getStartSymbol() {");
        indent();
        writeLine("return startFact;");
        dedent();
        writeLine("}");
        dedent();
        writeLine("}");
    }
}
